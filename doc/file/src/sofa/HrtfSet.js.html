<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <base data-ice="baseUrl" href="../../../">
  <title data-ice="title">src/sofa/HrtfSet.js | API Document</title>
  <link type="text/css" rel="stylesheet" href="css/style.css">
  <link type="text/css" rel="stylesheet" href="css/prettify-tomorrow.css">
  <script src="script/prettify/prettify.js"></script>
  
  
  <script src="script/manual.js"></script>
</head>
<body class="layout-container" data-ice="rootContainer">

<header>
  <a href="./">Home</a>
  
  <a href="identifiers.html">Reference</a>
  <a href="source.html">Source</a>
  
  <a data-ice="repoURL" href="https://github.com/Ircam-RnD/binauralFIR" class="repo-url-github">Repository</a>
  <div class="search-box">
  <span>
    <img src="./image/search.png">
    <span class="search-input-edge"></span><input class="search-input"><span class="search-input-edge"></span>
  </span>
    <ul class="search-result"></ul>
  </div>
</header>

<nav class="navigation" data-ice="nav"><div>
  <ul>
    
  <li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-description">description</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-license">license</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-name">name</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-version">version</a></span></span></li>
<li data-ice="doc"><div data-ice="dirPath" class="nav-dir-path">audio</div><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/audio/BinauralPanner.js~BinauralPanner.html">BinauralPanner</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/audio/Source.js~Source.html">Source</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-createDiracBuffer">createDiracBuffer</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-createNoiseBuffer">createNoiseBuffer</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-dBToLin">dBToLin</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-resampleFloat32Array">resampleFloat32Array</a></span></span></li>
<li data-ice="doc"><div data-ice="dirPath" class="nav-dir-path">common</div><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-almostEquals">almostEquals</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-almostEqualsModulo">almostEqualsModulo</a></span></span></li>
<li data-ice="doc"><div data-ice="dirPath" class="nav-dir-path">geometry</div><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/geometry/Listener.js~Listener.html">Listener</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-distance">distance</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-distanceSquared">distanceSquared</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-glToSofaCartesian">glToSofaCartesian</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-glToSofaSpherical">glToSofaSpherical</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-glToSpat4Cartesian">glToSpat4Cartesian</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-glToSpat4Spherical">glToSpat4Spherical</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-glToSystem">glToSystem</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-sofaCartesianToGl">sofaCartesianToGl</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-sofaCartesianToSofaSpherical">sofaCartesianToSofaSpherical</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-sofaSphericalToGl">sofaSphericalToGl</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-sofaSphericalToSofaCartesian">sofaSphericalToSofaCartesian</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-sofaToSofaCartesian">sofaToSofaCartesian</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-spat4CartesianToGl">spat4CartesianToGl</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-spat4CartesianToSpat4Spherical">spat4CartesianToSpat4Spherical</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-spat4SphericalToGl">spat4SphericalToGl</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-spat4SphericalToSpat4Cartesian">spat4SphericalToSpat4Cartesian</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-systemToGl">systemToGl</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-systemType">systemType</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-atan2">atan2</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-cos">cos</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-fromRadian">fromRadian</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-sin">sin</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-toRadian">toRadian</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-fromRadianFactor">fromRadianFactor</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-toRadianFactor">toRadianFactor</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-CoordinateSystem">CoordinateSystem</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-Coordinates">Coordinates</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-SofaCartesian">SofaCartesian</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-SofaSpherical">SofaSpherical</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-Spat4Cartesian">Spat4Cartesian</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-Spat4Spherical">Spat4Spherical</a></span></span></li>
<li data-ice="doc"><div data-ice="dirPath" class="nav-dir-path">sofa</div><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/sofa/HrtfSet.js~HrtfSet.html">HrtfSet</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/sofa/ServerDataBase.js~ServerDataBase.html">ServerDataBase</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-parseDataSet">parseDataSet</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-conformSofaCoordinateSystem">conformSofaCoordinateSystem</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-parseSofa">parseSofa</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-stringifySofa">stringifySofa</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-HrtfSet.nearestType">HrtfSet.nearestType</a></span></span></li>
</ul>
</div>
</nav>

<div class="content" data-ice="content"><h1 data-ice="title">src/sofa/HrtfSet.js</h1>
<pre class="source-code line-number raw-source-code"><code class="prettyprint linenums" data-ice="content">/**
 * @fileOverview Container for HRTF set: load a set from an URL and get
 * filters from corresponding positions.
 *
 * @author Jean-Philippe.Lambert@ircam.fr
 * @copyright 2015-2016 IRCAM, Paris, France
 * @license BSD-3-Clause
 */

import glMatrix from &apos;gl-matrix&apos;;

import info from &apos;../info&apos;;
import { parseDataSet } from &apos;./parseDataSet&apos;;
import { parseSofa, stringifySofa } from &apos;./parseSofa&apos;;
import { conformSofaCoordinateSystem } from &apos;./parseSofa&apos;;
import coordinates from &apos;../geometry/coordinates&apos;;
import kdTree from &apos;../geometry/KdTree&apos;;
import { resampleFloat32Array } from &apos;../audio/utilities&apos;;

/**
 * Container for HRTF set.
 */
export class HrtfSet {

  /**
   * Constructs an HRTF set. Note that the filter positions are applied
   * during the load of an URL.
   *
   * @see {@link HrtfSet#load}
   *
   * @param {Object} options
   * @param {AudioContext} options.audioContext mandatory for the creation
   * of FIR audio buffers
   * @param {CoordinateSystem} [options.coordinateSystem=&apos;gl&apos;]
   * {@link HrtfSet#coordinateSystem}
   * @param {CoordinateSystem} [options.filterCoordinateSystem=options.coordinateSystem]
   * {@link HrtfSet#filterCoordinateSystem}
   * @param {Array.&lt;Coordinates&gt;} [options.filterPositions=undefined]
   * {@link HrtfSet#filterPositions}
   * array of positions to filter. Use undefined to use all positions.
   * @param {Boolean} [options.filterAfterLoad=false] true to filter after
   * full load of SOFA file, instead of multiple partial loading.
   * {@link HrtfSet#filterAfterLoad}
   */
  constructor(options = {}) {
    this._audioContext = options.audioContext;

    this._ready = false;

    this.coordinateSystem = options.coordinateSystem;

    this.filterCoordinateSystem = options.filterCoordinateSystem;
    this.filterPositions = options.filterPositions;

    this.filterAfterLoad = options.filterAfterLoad;
  }

  // ------------ accessors

  /**
   * Set coordinate system for positions.
   * @param {CoordinateSystem} [system=&apos;gl&apos;]
   */
  set coordinateSystem(system) {
    this._coordinateSystem = (typeof system !== &apos;undefined&apos;
                              ? system
                              : &apos;gl&apos;);
  }

  /**
   * Get coordinate system for positions.
   *
   * @returns {CoordinateSystem}
   */
  get coordinateSystem() {
    return this._coordinateSystem;
  }

  /**
   * Set coordinate system for filter positions.
   *
   * @param {CoordinateSystem} [system] undefined to use coordinateSystem
   */
  set filterCoordinateSystem(system) {
    this._filterCoordinateSystem = (typeof system !== &apos;undefined&apos;
                                    ? system
                                    : this.coordinateSystem);
  }

  /**
   * Get coordinate system for filter positions.
   */
  get filterCoordinateSystem() {
    return this._filterCoordinateSystem;
  }

  /**
   * Set filter positions.
   *
   * @param {Array.&lt;Coordinates&gt;} [positions] undefined for no filtering.
   */
  set filterPositions(positions) {
    if (typeof positions === &apos;undefined&apos;) {
      this._filterPositions = undefined;
    } else {
      switch (this.filterCoordinateSystem) {
        case &apos;gl&apos;:
          this._filterPositions = positions.map( (current) =&gt; {
            return current.slice(0); // copy
          });
          break;

        case &apos;sofaCartesian&apos;:
          this._filterPositions = positions.map( (current) =&gt; {
            return coordinates.sofaCartesianToGl([], current);
          });
          break;

        case &apos;sofaSpherical&apos;:
          this._filterPositions = positions.map( (current) =&gt; {
            return coordinates.sofaSphericalToGl([], current);
          });
          break;

        default:
          throw new Error(&apos;Bad filter coordinate system&apos;);
      }
    }
  }

  /**
   * Get filter positions.
   */
  get filterPositions() {
    let positions;
    if (typeof this._filterPositions !== &apos;undefined&apos;) {
      switch (this.filterCoordinateSystem) {
        case &apos;gl&apos;:
          positions = this._filterPositions.map( (current) =&gt; {
            return current.slice(0); // copy
          });
          break;

        case &apos;sofaCartesian&apos;:
          positions = this._filterPositions.map( (current) =&gt; {
            return coordinates.glToSofaCartesian([], current);
          });
          break;

        case &apos;sofaSpherical&apos;:
          positions = this._filterPositions.map( (current) =&gt; {
            return coordinates.glToSofaSpherical([], current);
          });
          break;

        default:
          throw new Error(&apos;Bad filter coordinate system&apos;);
      }
    }
    return positions;
  }

  /**
   * Set post-filtering flag. When false, try to load a partial set of
   * HRTF.
   *
   * @param {Boolean} [post=false]
   */
  set filterAfterLoad(post) {
    this._filterAfterLoad = (typeof post !== &apos;undefined&apos;
                             ? post
                             : false);
  }

  /**
   * Get post-filtering flag. When false, try to load a partial set of
   * HRTF.
   *
   * @returns {Boolean}
   */
  get filterAfterLoad() {
    return this._filterAfterLoad;
  }

  /**
   * Test whether an HRTF set is actually loaded.
   *
   * @see {@link HrtfSet#load}
   *
   * @returns {Boolean} false before any successful load, true after.
   *
   */
  get isReady() {
    return this._ready;
  }

  /**
   * Get the original name of the HRTF set.
   *
   * @returns {String} that is undefined before a successfully load.
   */
  get sofaName() {
    return this._sofaName;
  }

  /**
   * Get the URL used to actually load the HRTF set.
   *
   * @returns {String} that is undefined before a successfully load.
   */
  get sofaUrl() {
    return this._sofaUrl;
  }

  /**
   * Get the original sample-rate from the SOFA URL already loaded.
   *
   * @returns {Number} that is undefined before a successfully load.
   */
  get sofaSampleRate() {
    return this._sofaSampleRate;
  }

  /**
   * Get the meta-data from the SOFA URL already loaded.
   *
   * @returns {Object} that is undefined before a successfully load.
   */
  get sofaMetaData() {
    return this._sofaMetaData;
  }

  // ------------- public methods

  /**
   * Apply filter positions to an existing set of HRTF. (After a successful
   * load.)
   *
   * This is destructive.
   *
   * @see {@link HrtfSet#load}
   */
  applyFilterPositions() {
    // do not use getter for gl positions
    let filteredPositions = this._filterPositions.map( (current) =&gt; {
      return this._kdt.nearest({ x: current[0], y: current[1], z: current[2] },
                               1)
        .pop()[0]; // nearest data
    });

    // filter out duplicates
    filteredPositions = [ ...new Set(filteredPositions) ];

    this._kdt = kdTree.tree.createKdTree(filteredPositions,
                                         kdTree.distanceSquared,
                                         [&apos;x&apos;, &apos;y&apos;, &apos;z&apos;]);
  }

  /**
   * Load an URL and generate the corresponding set of IR buffers.
   *
   * @param {String} sourceUrl
   * @returns {Promise.&lt;this|Error&gt;} resolve when the URL sucessfully
   * loaded.
   */
  load(sourceUrl) {
    const extension = sourceUrl.split(&apos;.&apos;).pop();

    const url = (extension === &apos;sofa&apos;
                 ? `${sourceUrl}.json`
                 : sourceUrl);

    let promise;

    // need a server for partial downloading (&quot;sofa&quot; extension may be naive)
    const preFilter = typeof this._filterPositions !== &apos;undefined&apos;
            &amp;&amp; !this.filterAfterLoad
            &amp;&amp; extension === &apos;sofa&apos;;
    if (preFilter) {
      promise = Promise.all([
        this._loadMetaAndPositions(sourceUrl),
        this._loadDataSet(sourceUrl),
      ])
        .then( (indicesAndDataSet) =&gt; {
          const indices = indicesAndDataSet[0];
          const dataSet = indicesAndDataSet[1];
          return this._loadSofaPartial(sourceUrl, indices, dataSet)
            .then( () =&gt; {
              this._ready = true;
              return this; // final resolve
            });
        })
        .catch( () =&gt; {
          // when pre-fitering fails, for any reason, try to post-filter
          // console.log(`Error while partial loading of ${sourceUrl}. `
          //             + `${error.message}. `
          //             + `Load full and post-filtering, instead.`);
          return this._loadSofaFull(url)
            .then( () =&gt; {
              this.applyFilterPositions();
              this._ready = true;
              return this; // final resolve
            });
        });
    } else {
      promise = this._loadSofaFull(url)
        .then( () =&gt; {
          if (typeof this._filterPositions !== &apos;undefined&apos;
              &amp;&amp; this.filterAfterLoad) {
            this.applyFilterPositions();
          }
          this._ready = true;
          return this; // final resolve
        });
    }

    return promise;
  }

  /**
   * Export the current HRTF set as a JSON string.
   *
   * When set, `this.filterPositions` reduce the actual number of filter, and
   * thus the exported set. The coordinate system of the export is
   * `this.filterCoordinateSystem`.
   *
   * @see {@link HrtfSet#filterCoordinateSystem}
   * @see {@link HrtfSet#filterPositions}
   *
   * @returns {String} as a SOFA JSON file.
   * @throws {Error} when this.filterCoordinateSystem is unknown.
   */
  export() {
    // in a SOFA file, the source positions are the HrtfSet filter positions.

    // SOFA listener is the reference for HrtfSet filter positions
    // which is normalised in HrtfSet

    let SourcePosition;
    const SourcePositionType = coordinates.systemType(
      this.filterCoordinateSystem);
    switch (SourcePositionType) {
      case &apos;cartesian&apos;:
        SourcePosition = this._sofaSourcePosition.map( (position) =&gt; {
          return coordinates.glToSofaCartesian([], position);
        });
        break;

      case &apos;spherical&apos;:
        SourcePosition = this._sofaSourcePosition.map( (position) =&gt; {
          return coordinates.glToSofaSpherical([], position);
        });
        break;

      default:
        throw new Error(`Bad source position type ${SourcePositionType} ` +
                        `for export.`);
    }

    const DataIR = this._sofaSourcePosition.map( (position) =&gt; {
      // retrieve fir for each position, without conversion
      const fir = this._kdt.nearest(
        { x: position[0], y: position[1], z: position[2] }, 1)
              .pop()[0].fir; // nearest data
      const ir = [];
      for (let channel = 0; channel &lt; fir.numberOfChannels; ++channel) {
        // Float32Array to array for stringify
        ir.push([... fir.getChannelData(channel) ] );
      }
      return ir;
    });

    return stringifySofa({
      name: this._sofaName,
      metaData: this._sofaMetaData,
      ListenerPosition: [0, 0, 0],
      ListenerPositionType: &apos;cartesian&apos;,
      ListenerUp: [0, 0, 1],
      ListenerUpType: &apos;cartesian&apos;,
      ListenerView: [1, 0, 0],
      ListenerViewType: &apos;cartesian&apos;,
      SourcePositionType,
      SourcePosition,
      DataSamplingRate: this._audioContext.sampleRate,
      DataDelay: this._sofaDelay,
      DataIR,
      RoomVolume: this._sofaRoomVolume,
    });
  }

  /**
   * @typedef {Object} HrtfSet.nearestType
   * @property {Number} distance from the request
   * @property {AudioBuffer} fir 2-channels impulse response
   * @property {Number} index original index in the SOFA set
   * @property {Coordinates} position using coordinateSystem coordinates
   * system.
   */

  /**
   * Get the nearest point in the HRTF set, after a successful load.
   *
   * @see {@link HrtfSet#load}
   *
   * @param {Coordinates} positionRequest
   * @returns {HrtfSet.nearestType}
   */
  nearest(positionRequest) {
    const position = coordinates.systemToGl([], positionRequest, this.coordinateSystem);
    const nearest = this._kdt.nearest({
      x: position[0],
      y: position[1],
      z: position[2],
    }, 1).pop(); // nearest only
    const data = nearest[0];
    coordinates.glToSystem(position, [data.x, data.y, data.z], this.coordinateSystem);
    return {
      distance: nearest[1],
      fir: data.fir,
      index: data.index,
      position,
    };
  }

  /**
   * Get the FIR AudioBuffer that corresponds to the closest position in
   * the set.
   * @param {Coordinates} positionRequest
   * @returns {AudioBuffer}
   */
  nearestFir(positionRequest) {
    return this.nearest(positionRequest).fir;
  }

  // ----------- private methods

  /**
   * Creates a kd-tree out of the specified indices, positions, and FIR.
   *
   * @private
   *
   * @param {Array} indicesPositionsFirs
   * @returns {this}
   */
  _createKdTree(indicesPositionsFirs) {
    const positions = indicesPositionsFirs.map( (value) =&gt; {
      const impulseResponses = value[2];
      const fir = this._audioContext.createBuffer(
        impulseResponses.length,
        impulseResponses[0].length,
        this._audioContext.sampleRate);
      impulseResponses.forEach( (samples, channel) =&gt; {
        // do not use copyToChannel because of Safari &lt;= 9
        fir.getChannelData(channel).set(samples);
      });

      return {
        index: value[0],
        x: value[1][0],
        y: value[1][1],
        z: value[1][2],
        fir,
      };
    });

    this._sofaSourcePosition = positions.map( (position) =&gt; {
      return [position.x, position.y, position.z];
    });

    this._kdt = kdTree.tree.createKdTree(positions,
                                         kdTree.distanceSquared,
                                         [&apos;x&apos;, &apos;y&apos;, &apos;z&apos;]);
    return this;
  }

  /**
   * Asynchronously create Float32Arrays, with possible re-sampling.
   *
   * @private
   *
   * @param {Array.&lt;Number&gt;} indices
   * @param {Array.&lt;Coordinates&gt;} positions
   * @param {Array.&lt;Float32Array&gt;} firs
   * @returns {Promise.&lt;Array|Error&gt;}
   * @throws {Error} assertion that the channel count is 2
   */
  _generateIndicesPositionsFirs(indices, positions, firs) {
    const sofaFirsPromises = firs.map( (sofaFirChannels, index) =&gt; {
      const channelCount = sofaFirChannels.length;
      if (channelCount !== 2) {
        throw new Error(`Bad number of channels`
                        + ` for IR index ${indices[index]}`
                        + ` (${channelCount} instead of 2)`);
      }

      const sofaFirsChannelsPromises = sofaFirChannels.map( (fir) =&gt; {
        return resampleFloat32Array({
          inputSamples: fir,
          inputSampleRate: this._sofaSampleRate,
          outputSampleRate: this._audioContext.sampleRate,
        });
      });
      return Promise.all(sofaFirsChannelsPromises)
        .then( (firChannels) =&gt; {
          return [
            indices[index],
            positions[index],
            firChannels,
          ];
        })
        .catch( (error) =&gt; {
          // re-throw
          throw new Error(
            `Unable to re-sample impulse response ${index}. ${error.message}`);
        });
    });
    return Promise.all(sofaFirsPromises);
  }

  /**
   * Try to load a data set from a SOFA URL.
   *
   * @private
   *
   * @param {String} sourceUrl
   * @returns {Promise.&lt;Object|Error&gt;}
   */
  _loadDataSet(sourceUrl) {
    const promise = new Promise( (resolve, reject) =&gt; {
      const ddsUrl = `${sourceUrl}.dds`;
      const request = new window.XMLHttpRequest();
      request.open(&apos;GET&apos;, ddsUrl);
      request.onerror = () =&gt; {
        reject(new Error(`Unable to GET ${ddsUrl}, status ${request.status} `
                         + `${request.responseText}`) );
      };

      request.onload = () =&gt; {
        if (request.status &lt; 200 || request.status &gt;= 300) {
          request.onerror();
          return;
        }

        try {
          const dds = parseDataSet(request.response);
          resolve(dds);
        } catch (error) {
          // re-throw
          reject(new Error(`Unable to parse ${ddsUrl}. ${error.message}`) );
        }
      }; // request.onload

      request.send();
    });

    return promise;
  }

  /**
   * Try to load meta-data and positions from a SOFA URL, to get the
   * indices closest to the filter positions.
   *
   * @private
   *
   * @param {String} sourceUrl
   * @returns {Promise.&lt;Array.&lt;Number&gt;|Error&gt;}
   */
  _loadMetaAndPositions(sourceUrl) {
    const promise = new Promise( (resolve, reject) =&gt; {
      const positionsUrl = `${sourceUrl}.json?`
              + `ListenerPosition,ListenerUp,ListenerView,SourcePosition,`
              + `Data.Delay,Data.SamplingRate,`
              + `EmitterPosition,ReceiverPosition,RoomVolume`; // meta

      const request = new window.XMLHttpRequest();
      request.open(&apos;GET&apos;, positionsUrl);
      request.onerror = () =&gt; {
        reject(new Error(`Unable to GET ${positionsUrl}, status ${request.status} `
                         + `${request.responseText}`) );
      };

      request.onload = () =&gt; {
        if (request.status &lt; 200 || request.status &gt;= 300) {
          request.onerror();
          return;
        }

        try {
          const data = parseSofa(request.response);
          this._setMetaData(data, sourceUrl);

          const sourcePositions = this._sourcePositionsToGl(data);
          const hrtfPositions = sourcePositions.map( (position, index) =&gt; {
            return {
              x: position[0],
              y: position[1],
              z: position[2],
              index,
            };
          });

          const kdt = kdTree.tree.createKdTree(
            hrtfPositions,
            kdTree.distanceSquared,
            [&apos;x&apos;, &apos;y&apos;, &apos;z&apos;]);

          let nearestIndices = this._filterPositions.map( (current) =&gt; {
            return kdt.nearest({ x: current[0], y: current[1], z: current[2] },
                               1)
              .pop()[0] // nearest data
              .index;
          });

          // filter out duplicates
          nearestIndices = [ ...new Set(nearestIndices) ];

          this._sofaUrl = sourceUrl;
          resolve(nearestIndices);
        } catch (error) {
          // re-throw
          reject(new Error(`Unable to parse ${positionsUrl}. ${error.message}`) );
        }
      }; // request.onload

      request.send();
    });

    return promise;
  }

  /**
   * Try to load full SOFA URL.
   *
   * @private
   *
   * @param {String} url
   * @returns {Promise.&lt;this|Error&gt;}
   */
  _loadSofaFull(url) {
    const promise = new Promise( (resolve, reject) =&gt; {
      const request = new window.XMLHttpRequest();
      request.open(&apos;GET&apos;, url);
      request.onerror = () =&gt; {
        reject(new Error(`Unable to GET ${url}, status ${request.status} `
                         + `${request.responseText}`) );
      };

      request.onload = () =&gt; {
        if (request.status &lt; 200 || request.status &gt;= 300) {
          request.onerror();
          return;
        }

        try {
          const data = parseSofa(request.response);
          this._setMetaData(data, url);
          const sourcePositions = this._sourcePositionsToGl(data);
          this._generateIndicesPositionsFirs(
            sourcePositions.map( (position, index) =&gt; index), // full
            sourcePositions,
            data[&apos;Data.IR&apos;].data
          )
            .then( (indicesPositionsFirs) =&gt; {
              this._createKdTree(indicesPositionsFirs);
              this._sofaUrl = url;
              resolve(this);
            });

        } catch (error) {
          // re-throw
          reject(new Error(`Unable to parse ${url}. ${error.message}`) );
        }
      }; // request.onload

      request.send();
    });

    return promise;
  }

  /**
   * Try to load partial data from a SOFA URL.
   *
   * @private
   *
   * @param {Array.&lt;String&gt;} sourceUrl
   * @param {Array.&lt;Number&gt;} indices
   * @param {Object} dataSet
   * @returns {Promise.&lt;this|Error&gt;}
   */
  _loadSofaPartial(sourceUrl, indices, dataSet) {
    const urlPromises = indices.map( (index) =&gt; {
      const urlPromise = new Promise( (resolve, reject) =&gt; {
        const positionUrl = `${sourceUrl}.json?`
                + `SourcePosition[${index}][0:1:${dataSet.SourcePosition.C - 1}],`
                + `Data.IR[${index}][0:1:${dataSet[&apos;Data.IR&apos;].R - 1}]`
                + `[0:1:${dataSet[&apos;Data.IR&apos;].N - 1}]`;

        const request = new window.XMLHttpRequest();
        request.open(&apos;GET&apos;, positionUrl);
        request.onerror = () =&gt; {
          reject(new Error(`Unable to GET ${positionUrl}, status ${request.status} `
                           + `${request.responseText}`) );
        };

        request.onload = () =&gt; {
          if (request.status &lt; 200 || request.status &gt;= 300) {
            request.onerror();
          }

          try {
            const data = parseSofa(request.response);
            // (meta-data is already loaded)

            const sourcePositions = this._sourcePositionsToGl(data);
            this._generateIndicesPositionsFirs([index],
                                               sourcePositions,
                                               data[&apos;Data.IR&apos;].data)
              .then( (indicesPositionsFirs) =&gt; {
                // One position per URL here
                // Array made of multiple promises, later
                resolve(indicesPositionsFirs[0]);
              });
          } catch (error) {
            // re-throw
            reject(new Error(
              `Unable to parse ${positionUrl}. ${error.message}`) );
          }
        }; // request.onload

        request.send();
      });

      return urlPromise;
    });

    return Promise.all(urlPromises)
      .then( (indicesPositionsFirs) =&gt; {
        this._createKdTree(indicesPositionsFirs);
        return this; // final resolve
      });
  }

  /**
   * Set meta-data, and assert for supported HRTF type.
   *
   * @private
   *
   * @param {Object} data
   * @param {String} sourceUrl
   * @throws {Error} assertion for FIR data.
   */
  _setMetaData(data, sourceUrl) {
    if (typeof data.metaData.DataType !== &apos;undefined&apos;
        &amp;&amp; data.metaData.DataType !== &apos;FIR&apos;) {
      throw new Error(&apos;According to meta-data, SOFA data type is not FIR&apos;);
    }

    const dateString = new Date().toISOString();

    this._sofaName = (typeof data.name !== &apos;undefined&apos;
                      ? `${data.name}`
                      : `HRTF.sofa`);

    this._sofaMetaData = (typeof data.metaData !== &apos;undefined&apos;
                          ? data.metaData
                          : {} );

    // append conversion information
    if (typeof sourceUrl !== &apos;undefined&apos;) {
      this._sofaMetaData.OriginalUrl = sourceUrl;
    }

    this._sofaMetaData.Converter = `Ircam ${info.name} ${info.version} `
      + `javascript API `;
    this._sofaMetaData.DateConverted = dateString;

    this._sofaSampleRate = (typeof data[&apos;Data.SamplingRate&apos;] !== &apos;undefined&apos;
                            ? data[&apos;Data.SamplingRate&apos;].data[0]
                            : 48000); // Table C.1
    if (this._sofaSampleRate !== this._audioContext.sampleRate) {
      this._sofaMetaData.OriginalSampleRate = this._sofaSampleRate;
    }

    this._sofaDelay = (typeof data[&apos;Data.Delay&apos;] !== &apos;undefined&apos;
                         ? data[&apos;Data.Delay&apos;].data[0]
                         : 0);

    this._sofaRoomVolume = (typeof data.RoomVolume !== &apos;undefined&apos;
                            ? data.RoomVolume.data[0]
                            : undefined);

    // Convert listener position, up, and view to SOFA cartesian,
    // to generate a SOFA-to-GL look-at mat4.
    // Default SOFA type is &apos;cartesian&apos; (see table D.4A).

    const listenerPosition = coordinates.sofaToSofaCartesian(
      [], data.ListenerPosition.data[0],
      conformSofaCoordinateSystem(data.ListenerPosition.Type || &apos;cartesian&apos;) );

    const listenerView = coordinates.sofaToSofaCartesian(
      [], data.ListenerView.data[0],
      conformSofaCoordinateSystem(data.ListenerView.Type || &apos;cartesian&apos;) );

    const listenerUp = coordinates.sofaToSofaCartesian(
      [], data.ListenerUp.data[0],
      conformSofaCoordinateSystem(data.ListenerUp.Type || &apos;cartesian&apos;) );

    this._sofaToGl = glMatrix.mat4.lookAt(
      [], listenerPosition, listenerView, listenerUp);
  }

  /**
   * Convert to GL coordinates, in-place.
   *
   * @private
   *
   * @param {Object} data
   * @returns {Array.&lt;Coordinates&gt;}
   * @throws {Error}
   */
  _sourcePositionsToGl(data) {
    const sourcePositions = data.SourcePosition.data; // reference
    const sourceCoordinateSystem = (typeof data.SourcePosition.Type !== &apos;undefined&apos;
                                    ? data.SourcePosition.Type
                                    : &apos;spherical&apos;); // default (SOFA Table D.4C)
    switch (sourceCoordinateSystem) {
      case &apos;cartesian&apos;:
        sourcePositions.forEach( (position) =&gt; {
          glMatrix.vec3.transformMat4(position, position,
                                      this._sofaToGl);
        });
        break;

      case &apos;spherical&apos;:
        sourcePositions.forEach( (position) =&gt; {
          coordinates.sofaSphericalToSofaCartesian(position, position); // in-place
          glMatrix.vec3.transformMat4(position, position,
                                      this._sofaToGl);
        });
        break;

      default:
        throw new Error(&apos;Bad source position type&apos;);
    }

    return sourcePositions;
  }

}

export default HrtfSet;
</code></pre>

</div>

<footer class="footer">
  Generated by <a href="https://esdoc.org">ESDoc<span data-ice="esdocVersion">(0.4.7)</span></a>
</footer>

<script src="script/search_index.js"></script>
<script src="script/search.js"></script>
<script src="script/pretty-print.js"></script>
<script src="script/inherited-summary.js"></script>
<script src="script/test-summary.js"></script>
<script src="script/inner-link.js"></script>
<script src="script/patch-for-local.js"></script>
</body>
</html>
