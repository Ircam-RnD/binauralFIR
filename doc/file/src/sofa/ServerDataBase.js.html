<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <base data-ice="baseUrl" href="../../../">
  <title data-ice="title">src/sofa/ServerDataBase.js | API Document</title>
  <link type="text/css" rel="stylesheet" href="css/style.css">
  <link type="text/css" rel="stylesheet" href="css/prettify-tomorrow.css">
  <script src="script/prettify/prettify.js"></script>
  
  
  <script src="script/manual.js"></script>
</head>
<body class="layout-container" data-ice="rootContainer">

<header>
  <a href="./">Home</a>
  
  <a href="identifiers.html">Reference</a>
  <a href="source.html">Source</a>
  
  <a data-ice="repoURL" href="https://github.com/Ircam-RnD/binauralFIR" class="repo-url-github">Repository</a>
  <div class="search-box">
  <span>
    <img src="./image/search.png">
    <span class="search-input-edge"></span><input class="search-input"><span class="search-input-edge"></span>
  </span>
    <ul class="search-result"></ul>
  </div>
</header>

<nav class="navigation" data-ice="nav"><div>
  <ul>
    
  <li data-ice="doc"><div data-ice="dirPath" class="nav-dir-path">audio</div><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/audio/BinauralPanner.js~BinauralPanner.html">BinauralPanner</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/audio/Source.js~Source.html">Source</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-createDiracBuffer">createDiracBuffer</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-createNoiseBuffer">createNoiseBuffer</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-dBToLin">dBToLin</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-resampleFloat32Array">resampleFloat32Array</a></span></span></li>
<li data-ice="doc"><div data-ice="dirPath" class="nav-dir-path">common</div><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-almostEquals">almostEquals</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-almostEqualsModulo">almostEqualsModulo</a></span></span></li>
<li data-ice="doc"><div data-ice="dirPath" class="nav-dir-path">geometry</div><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-distance">distance</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-distanceSquared">distanceSquared</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-glToSofaCartesian">glToSofaCartesian</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-glToSofaSpherical">glToSofaSpherical</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-glToTyped">glToTyped</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-sofaCartesianToGl">sofaCartesianToGl</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-sofaCartesianToSofaSpherical">sofaCartesianToSofaSpherical</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-sofaSphericalToGl">sofaSphericalToGl</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-sofaSphericalToSofaCartesian">sofaSphericalToSofaCartesian</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-typedToGl">typedToGl</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-typedToSofaCartesian">typedToSofaCartesian</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-atan2">atan2</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-cos">cos</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-fromRadian">fromRadian</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-sin">sin</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-toRadian">toRadian</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-fromRadianFactor">fromRadianFactor</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-toRadianFactor">toRadianFactor</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-coordinates">coordinates</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-coordinatesType">coordinatesType</a></span></span></li>
<li data-ice="doc"><div data-ice="dirPath" class="nav-dir-path">sofa</div><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/sofa/HrtfSet.js~HrtfSet.html">HrtfSet</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/sofa/ServerDataBase.js~ServerDataBase.html">ServerDataBase</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-parseDataSet">parseDataSet</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-conformSofaType">conformSofaType</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-parseSofa">parseSofa</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-HrtfSet.nearestType">HrtfSet.nearestType</a></span></span></li>
</ul>
</div>
</nav>

<div class="content" data-ice="content"><h1 data-ice="title">src/sofa/ServerDataBase.js</h1>
<pre class="source-code line-number raw-source-code"><code class="prettyprint linenums" data-ice="content">/**
 * @fileOverview Access a remote catalogue from a SOFA server, and get URLs
 * with filtering.
 *
 * @author Jean-Philippe.Lambert@ircam.fr
 * @copyright 2015-2016 IRCAM, Paris, France
 * @license BSD-3-Clause
 */

import parseXml from &apos;./parseXml&apos;;
import { parseDataSet } from &apos;./parseDataSet&apos;;

/**
 * SOFA remote data-base.
 */
export class ServerDataBase {
  /**
   * This is only a constructor, it does not load any thing.
   *
   * See {@link ServerDataBase#loadCatalogue}.
   *
   * @param {Object} [options]
   * @param {String} [options.serverUrl] base URL of server, including
   * protocol, eg. &apos;http://bili2.ircam.fr&apos;.
   */
  constructor(options = {}) {
    this._server = options.serverUrl;

    if (typeof this._server === &apos;undefined&apos;) {
      const protocol = (window.location.protocol === &apos;https:&apos;
                        ? &apos;https:&apos;
                        : &apos;http:&apos;);

      this._server = `${protocol}//bili2.ircam.fr`;
    }

    this._catalogue = {};
    this._urls = [];
  }

  /**
   * Asynchronously load complete catalogue from the server, including the
   * catalogue links found in any partial catalogue.
   *
   * @param {String} [sourceUrl] URL of the root catalogue, including the
   * server, like &apos;http://bili2.ircam.fr/catalog.xml&apos;.
   *  Default is &apos;catalog.xml&apos; at serverURL supplied at
   * {@link ServerDataBase#constructor}.
   * @param {Object} [destination] Catalogue to update. Default is
   * internal.
   * @returns {Promise.&lt;String|Error&gt;} The promise will resolve (with
   * sourceUrl) when every sub-catalogue will successfully load, or will
   * reject (with an error) as soon as one transfer fails.
   */
  loadCatalogue(sourceUrl = `${this._server}/catalog.xml`,
                destination = this._catalogue) {
    const promise = new Promise( (resolve, reject) =&gt; {
      const request = new window.XMLHttpRequest();
      request.open(&apos;GET&apos;, sourceUrl);
      request.onerror = () =&gt; {
        reject(new Error(`Unable to GET ${sourceUrl}, status ${request.status} `
                         + `${request.responseText}`) );
      };

      request.onload = () =&gt; {
        if (request.status &lt; 200 || request.status &gt;= 300) {
          request.onerror();
          return;
        }

        const xml = parseXml(request.response);
        const dataSet = xml.querySelector(&apos;dataset&apos;);

        // recursive catalogues
        const catalogueReferences = xml.querySelectorAll(&apos;dataset &gt; catalogRef&apos;);

        if (catalogueReferences.length === 0) {
          // end of recursion
          destination.urls = [];
          const urls = xml.querySelectorAll(&apos;dataset &gt; dataset&apos;);
          for (let ref = 0; ref &lt; urls.length; ++ref) {
            // data set name already contains a leading slash
            const url = this._server
                    + dataSet.getAttribute(&apos;name&apos;) + &apos;/&apos;
                    + urls[ref].getAttribute(&apos;name&apos;);
            this._urls.push(url);
            destination.urls.push(url);
          }

          resolve(sourceUrl);
        } else {
          // recursion
          const promises = [];
          for (let ref = 0; ref &lt; catalogueReferences.length; ++ref) {
            const name = catalogueReferences[ref].getAttribute(&apos;name&apos;);
            const recursiveUrl = this._server
                    + dataSet.getAttribute(&apos;name&apos;) + &apos;/&apos;
                    + catalogueReferences[ref].getAttribute(&apos;xlink:href&apos;);
            destination[name] = {};
            promises.push(this.loadCatalogue(recursiveUrl, destination[name]) );
          }

          Promise.all(promises)
            .then( () =&gt; {
              this._urls.sort();
              resolve(sourceUrl);
            })
            .catch( (error) =&gt; {
              reject(error);
            });
        }
      }; // request.onload

      request.send();
    });

    return promise;
  }

  /**
   * Get URLs, possibly filtered.
   *
   * Any filter can be partial, and is case-insensitive. The result must
   * match every supplied filter. Undefined filters are not applied.
   *
   * @param {Object} [options] optional filters
   * @param {String} [options.convention] &apos;HRIR&apos; or &apos;SOS&apos;
   * @param {String} [options.dataBase] &apos;LISTEN&apos;, &apos;BILI&apos;, etc.
   * @param {String} [options.equalisation] &apos;RAW&apos;,&apos;COMPENSATED&apos;
   * @param {String} [options.sampleRate] in Hertz
   * @param {String} [options.sosOrder] &apos;12order&apos; or &apos;24order&apos;
   * @param {String} [options.freePattern] any pattern matched
   * globally. Use separators (spaces, tabs, etc.) to combine multiple
   * patterns: &apos;44100 listen&apos; will restrict on URLs matching &apos;44100&apos; and
   * &apos;listen&apos;
   * @returns {Array.&lt;String&gt;} URLs that match every filter.
   */
  getUrls(options = {}) {
    // the number and the order of the filters in the following array must
    // match the URL sub-directories
    const filters = [
      options.convention,
      options.dataBase,
      options.equalisation,
      options.sampleRate,
      options.sosOrder, // in file name
    ];

    // any where in URL
    const freePattern = (typeof options.freePattern === &apos;number&apos;
                         ? options.freePattern.toString()
                         : options.freePattern);

    const pattern = filters.reduce( (global, local) =&gt; {
      // partial filter inside slashes
      return `${global}/` + (typeof local !== &apos;undefined&apos;
                             ? `[^/]*${local}[^/]*`
                             : &apos;[^/]*&apos;);
    }, &apos;&apos;);

    let regExp = new RegExp(pattern, &apos;i&apos;);

    let urls = this._urls.filter( (url) =&gt; {
      return regExp.test(url);
    });

    if (typeof freePattern !== &apos;undefined&apos;) {
      // split patterns with separators
      const patterns = freePattern.split(/\s+/);
      patterns.forEach( (current) =&gt; {
        regExp = new RegExp(current, &apos;i&apos;);

        urls = urls.filter( (url) =&gt; {
          return regExp.test(url);
        });
      });
    }

    return urls;
  }

  /**
   * Get all source positions of a given URL.
   *
   * @param {String} sourceUrl is the complete SOFA URL, with the
   * server, like
   * &apos;http://bili2.ircam.fr/SimpleFreeFieldHRIR/BILI/COMPENSATED/44100/IRC_1100_C_HRIR.sofa&apos;
   *
   * @returns {Promise.&lt;Object|String&gt;} The promise will resolve after
   * successfully loading, with definitions as * `{definition: {key: values}}`
   * objects; the promise will reject is the transfer fails, with an error.
   */
  getDataSetDefinitions(sourceUrl) {
    const promise = new Promise( (resolve, reject) =&gt; {
      const url = `${sourceUrl}.dds`;
      const request = new window.XMLHttpRequest();
      request.open(&apos;GET&apos;, url);
      request.onerror = () =&gt; {
        reject(new Error(`Unable to GET ${url}, status ${request.status} `
                         + `${request.responseText}`) );
      };

      request.onload = () =&gt; {
        if (request.status &lt; 200 || request.status &gt;= 300) {
          request.onerror();
          return;
        }
        resolve(parseDataSet(request.response) );
      }; // request.onload

      request.send();
    });

    return promise;
  }

  /**
   * Get all source positions of a given URL.
   *
   * @param {String} sourceUrl is the complete SOFA URL, with the
   * server, like
   * &apos;http://bili2.ircam.fr/SimpleFreeFieldHRIR/BILI/COMPENSATED/44100/IRC_1100_C_HRIR.sofa&apos;
   *
   * @returns {Promise.&lt;Array&lt;Array.&lt;Number&gt;&gt;|Error&gt;} The promise will resolve
   * after successfully loading, with an array of positions (which are
   * arrays of 3 numbers); the promise will reject is the transfer fails,
   * with an error.
   */
  getSourcePositions(sourceUrl) {
    const promise = new Promise( (resolve, reject) =&gt; {
      const url = `${sourceUrl}.json?SourcePosition`;

      const request = new window.XMLHttpRequest();
      request.open(&apos;GET&apos;, url);
      request.onerror = () =&gt; {
        reject(new Error(`Unable to GET ${url}, status ${request.status} `
                         + `${request.responseText}`) );
      };

      request.onload = () =&gt; {
        if (request.status &lt; 200 || request.status &gt;= 300) {
          request.onerror();
          return;
        }

        try {
          const response = JSON.parse(request.response);
          if (response.leaves[0].name !== &apos;SourcePosition&apos;) {
            throw new Error(&apos;SourcePosition not found&apos;);
          }

          resolve(response.leaves[0].data);
        } catch (error) {
          // re-throw
          reject(new Error(`Unable to parse response from ${url}. ${error.message}`) );
        }
      }; // request.onload

      request.send();
    });

    return promise;
  }

}

export default ServerDataBase;
</code></pre>

</div>

<footer class="footer">
  Generated by <a href="https://esdoc.org">ESDoc<span data-ice="esdocVersion">(0.4.4)</span></a>
</footer>

<script src="script/search_index.js"></script>
<script src="script/search.js"></script>
<script src="script/pretty-print.js"></script>
<script src="script/inherited-summary.js"></script>
<script src="script/test-summary.js"></script>
<script src="script/inner-link.js"></script>
<script src="script/patch-for-local.js"></script>
</body>
</html>
